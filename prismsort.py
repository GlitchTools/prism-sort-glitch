#!/usr/bin/env python3

# Prism Sort glitch algorithm v1.0
# Copyright 2016 Mathieu Guimond-Morganti

# This program is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License.
# To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/4.0/.

# TL;DR:
# The artwork generated by this program constitute "Adapted Material" under the terms of the CC-BY-SA 4.0 license, 
# and therefore should be attributed and licensed accordingly.
# Something like "This artwork is a derivative of the Prism Sort algorithm by Mathieu Guimond-Morganti, licensed under CC-BY-SA." would be perfect!
# If you intend to distribute the resulting artwork, make sure the input image is yours,
# or in the public domain, or licensed under a similar copyleft license :)
# Finally, if you feel generous or you want to get in touch, my email is guimondmm at gmail dot com

from random import *
from math import sqrt, radians as rad, cos, sin
from platform import system
import sys, getopt
try:
	from PIL import Image, ImageOps # requires the Pillow module and its dependencies ($ pip3 install Pillow)
	# http://pillow.readthedocs.org/en/3.1.x/installation.html
except ImportError:
	print("\n\x1B[31mThis Python 3 script requires the \x1B[31;1mPillow\x1B[0m\x1B[31m module and its dependencies.\nTry the command:")
	print("\x1B[31;1m$ pip3 install Pillow\x1B[0m\x1B[31m")
	print("or visit \x1B[31;1mhttp://pillow.readthedocs.org/en/3.1.x/installation.html\n\x1B[0m")
	sys.exit(1)

## default parameters
IMAGE_WIDTH, IMAGE_HEIGHT = None, None # will be initialized later
resizeFact = 1 # each dimension will be resized by sqrt(resizeFact), so a resizeFact of 2 makes image twice as small
blocks = 9 # size of a block is each dimension of the picture divided by this
numOutput = 1 # how many different images to output
dither = False # randomizes the glitch so it looks noisier but less blocky
intensity = 0 # tweaks the probability of line corruption, based on an empirical formula I pulled out of my a**
rotation = 0 # defaults to vertical
jpeg = None # save as JPEG
fuzzyedges = False # if True, don't crop the output as much (rotation must be non-zero)
eegg = [] # empty list
usage = '''
Prism Sort glitch algorithm v1.0
\xA9 2016 Mathieu Guimond-Morganti, licensed under CC-BY-SA 4.0

Usage: python3 prismsort.py inputfile [options]
-a, --angle=NUM     : rotates the glitch effect by this many degrees
                      (default: 0, i.e. vertical)
-b, --blocks=NUM    : number of blocks (default: 9)
                      affects the overlapping of the glitch effect
                      (higher = more intense)
-d, --dither        : makes result more noisy, and less blocky
-f, --fuzzyedges    : in combination with a rotation, will leave a fuzzy black 
                      border around the image
-h, --help          : displays this help message
-H, --horizontal    : processes the image horizontally (same as -a 90)
-i, --intensity=NUM : intensity [recommended: -2~2; default: 0]
                      will not go lower than (3 - number of blocks)
-J, --jpeg=NUM      : saves as JPEG at the specified quality
                      (recommended: 75~95)
-n, --numoutput=NUM : number of output files to be generated (default: 1)
                      the output files are in the format:
                      <originalfilename>_out<number>.<ext>
                      files are overwritten without warning!
-P, --png           : saves as PNG (default)
-r, --resize=NUM    : resize factor (e.g. 2 divides side by sqrt(2); optional)
-V, --vertical      : processes the image vertically (default; same as -a 0)
'''

def openImage(file, resize) :
	'''Opens a given picture file, resizes it as needed, then returns an Image object, its width as an int, and its height as an int'''
	image = Image.open(file)
	image = image.convert('RGB') # because don't want to manipulate JPEGs directly
	if resize != 1 :
		image = image.resize((int(image.size[0]/sqrt(resize)), int(image.size[1]/sqrt(resize))), Image.LANCZOS) # makes image smaller for speed
	width, height = int(image.size[0]), int(image.size[1])
	return image, width, height

def probability(p) :
	'''Fairly self-explanatory; determines if a certain event occurs based on its probability; returns a boolean'''
	return True if random() < p else False

def partialSort(numList) :
	'''Sorts some of the elements of a list of numbers (within a randomly selected range), and returns the partially sorted list'''
	ls = list(numList)
	a = randrange(len(ls) - 1) # lower bound
	b = randrange(a + 1, len(ls)) # upper bound
	if probability(0.5) : 
		if probability(0.95) :
			ls = ls[0:a] + sorted(ls[a:b]) + ls[b:] # sorts the middle
		else :
			ls = sorted(ls[0:b]) + ls[b:] # sorts the beginning
	else :
		if probability(0.95) :
			ls = ls[0:a] + list(reversed(sorted(ls[a:b]))) + ls[b:] # sorts the middle, in decreasing order
		else: 
			ls = ls[0:a] + list(reversed(sorted(ls[a:]))) # sorts the end, in decreasing order
	return ls

def progress(counter = 0, total = None, done = False, eegg = []) :
	'''Displays a rudimentary progression counter.'''
	if done :
		print('.' * 10, "Done!", end="")
		print("" if not eegg else " \U0001F60A\x1B[0m" if system() == "\x44\x61\x72\x77\x69\x6E" else " \x3A\x29\x1B[0m")
	elif total != None :
		print("" if not eegg else "\x1B["+str(31+(counter-1)%6)+";1m", end="")
		print(counter, "/", total) # fraction
	else :
		out = int((counter/2)/(IMAGE_WIDTH if IMAGE_WIDTH >= IMAGE_HEIGHT else IMAGE_HEIGHT) *10)
		print(out * '.' + (10 - out) * ' ', end="\r") # animated sequence of dots
		

def pixSort(image, startW = 0, startH = 0, endW = IMAGE_WIDTH, endH = IMAGE_HEIGHT, p = 0.8) :
	'''The purposefully proken pixel sort function that glitches the picture.
	Glitches a block of pixels within the image based on a probability of a given line being sorted.'''
	for y in range(startH, endH): # for each line of the pic
		progress(y)
		if probability(p) :
			line = []
			for x in range(startW, endW):
				try :
					line.append(image.getpixel((y,x))) # makes list of every pixel RGB value on the line as tuple
				except IndexError: # if out of bounds of the picture
					break
			originalLine = list(line) # backup of the line before sort, to unglitch a channel later
			try :
				line = partialSort(line)
			except ValueError: # if we broke out of the previous loop we might get a crash here due to out of bounds
				pass # My code is bad, and I should feel bad.
			## restore one of the original channels at random (makes the result colourful)
			if probability(p * 3 / 4) :
				colour = randrange(3) # 0 = R, 1 = G, 2 = B
				for px in range(len(line)) :
					line[px] = ((originalLine[px][0] if colour == 0 else line[px][0]), (originalLine[px][1] if colour == 1 else line[px][1]), (originalLine[px][2] if colour == 2 else line[px][2]))
			## makes the actual changes to the image object
			for x in range(len(line)):
				try:
					image.putpixel((y + (randrange(1,3) if probability(0.1) and dither else 1), startW + x), (line[x]))
				except IndexError: # out of bounds of the picture
					break
	return image

def glitch(image, blocks = 9, rotation = None) :
	'''Glitches an Image object according to a number of blocks and an optional rotation; returns the glitched Image object'''
	wBlock, hBlock = int(IMAGE_WIDTH/blocks), int(IMAGE_HEIGHT/blocks) # the script works with overlapping squares in the picture

	## rotation
	if rotation != 0:
		image = image.rotate(rotation, resample=Image.BICUBIC, expand=True)
	if rotation == 0 or abs(rotation) == 90 :
		image = ImageOps.expand(image, border=(wBlock if wBlock >= hBlock else hBlock), fill=0)

	## glitch loop
	currentHeight = 0
	while currentHeight + hBlock * 2 / 3 <= (IMAGE_HEIGHT if IMAGE_HEIGHT >= IMAGE_WIDTH else IMAGE_WIDTH)*2 :
		currentWidth = 0
		while currentWidth + wBlock * 2 / 3 <= (IMAGE_WIDTH if IMAGE_WIDTH >= IMAGE_HEIGHT else IMAGE_HEIGHT)*2 :
			## I pulled the following formula out of my a**, but empirically it seemed to yield the best p values for blocks between 5 and 11
			image = pixSort(image, currentHeight, currentWidth, currentHeight + hBlock, currentWidth + wBlock, p = 1 - (blocks**2 / (blocks + 1)**2) ** randrange(blocks - 4 + intensity, blocks - 1 + intensity))
			currentWidth += int(wBlock * 2/3) if blocks > 1 else wBlock
		currentHeight += int(hBlock * 2/3) if blocks > 1 else hBlock

	## rotation 2: electric boogaloo
	image = image.rotate(-rotation, resample=Image.BICUBIC, expand=True) if rotation != 0 else image

	return image

def main():
	'''Main loop; opens and saves the picture file'''
	try:
		iteration = 0
		while iteration < numOutput :
			progress(iteration + 1, total=numOutput, eegg=eegg)

			## opening the file and glitching it
			im = openImage(FILENAME, resizeFact)[0]
			im = glitch(im, blocks, rotation)

			if rotation != None:
				trig = abs(sin(rad(rotation))) if abs(sin(rad(rotation))) > abs(cos(rad(rotation))) else abs(cos(rad(rotation))) # to optimize the fuzzyedges
				left = int((im.width - IMAGE_WIDTH - (0 if not fuzzyedges else IMAGE_WIDTH/blocks*trig))/2) # basically crops to original size, except if fuzzyedges
				top = int((im.height - IMAGE_HEIGHT - (0 if not fuzzyedges else IMAGE_HEIGHT/blocks*trig))/2)
				right = int(IMAGE_WIDTH + (im.width - IMAGE_WIDTH + (0 if not fuzzyedges else IMAGE_WIDTH/blocks*trig))/2)
				bottom = int(IMAGE_HEIGHT + (im.height - IMAGE_HEIGHT + (0 if not fuzzyedges else IMAGE_HEIGHT/blocks*trig))/2)
				im = im.crop(box=(left, top, right, bottom)) # crops the black border

			## saving the output
			if jpeg == None :
				im.save(FILENAME.split('.')[0]+'_out'+str(iteration)+".png")
			else :
				im.save(FILENAME.split('.')[0]+'_out'+str(iteration)+".jpg", optimize=True, quality=jpeg, subsampling=0) # see Pillow doc

			iteration += 1
			progress(done=True, eegg=eegg)

	except KeyboardInterrupt:
		print("\nCancelled." if not eegg else "\n\x1B[0m\U0001F308" if system() == "\x44\x61\x72\x77\x69\x6E" else " \x3A\x27\x28\x1B[0m")
		sys.exit(1)

## reading command-line parameters and launching the main loop
if __name__ == "__main__":
	try:
		FILENAME = sys.argv[1]
		opts, args = getopt.getopt(sys.argv[2:],"hHVdPfi:r:b:n:J:a:", ["fuzzyedges", "angle=", "help", "blocks=", "numoutput=", "resize=", "dither", "intensity=", "horizontal", "vertical", "jpeg=", "png", "\x67\x61\x79"])
	except (IndexError, getopt.GetoptError): # IndexError if FILENAME unspecified
		print(usage)
		sys.exit(2)
	for opt, arg in opts:
		if opt in ('-h', '--help'): # prints help message and exits
			print(usage)
			sys.exit()
		elif opt in ('-b', '--blocks'): # affects size and number of glitch blocks
			blocks = int(arg)
		elif opt in ('-n', '--numoutput'): # number of output files generated
			numOutput = int(arg)
		elif opt in ('-r', '--resize'): # resize factor (each side by sqrt(arg))
			resizeFact = int(arg)
		elif opt in ('-d', '--dither'): # effect more noisy, less blocky
			dither = True
		elif opt in ('-i', '--intensity'): # intensity affects probability of the effect
			intensity = int(arg)
		elif opt in ('-H', '--horizontal'): # rotate by 90 degrees, apply effect, undo rotation
			rotation = 90
		elif opt in ('-V', '--vertical'): # useless by default
			rotation = 0
		elif opt in ('\x2D\x2D\x67\x61\x79'): # puts some joy in your life
			eegg.append('')
		elif opt in ('-J', '--jpeg'): # output in jpeg with given quality
			jpeg = int(arg)
		elif opt in ('-P', '--png'): # useless by default
			jpeg = None
		elif opt in ('-a', '--angle'): 
			rotation = int(arg)
		elif opt in ('-f', '--fuzzyedges'):
			fuzzyedges = True
	intensity = intensity if blocks + intensity >= 3 else 3 - blocks # failsafe, otherwise yields poor results
	IMAGE_WIDTH, IMAGE_HEIGHT = openImage(FILENAME, resizeFact)[1:]
	main()
